<?php

/**
 * @file
 * The main functionality of this module.
 */

/**
 * Implements hook_menu().
 */
function germ_summary_menu() {
  // Home - display a summary matrix showing siblings count under parents.
  $items['germplasm/summary'] = array(
    'title' => 'Germplasm Summary',
    'access arguments' => array('access content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('germ_summary_form', 2),
    'type' => MENU_NORMAL_ITEM,
  );

  // Menu callback - display number of siblings table. (% - /mom/dad)
  $items['germplasm/list/%/%/%'] = array(
    'title' => 'Germplasm List',
    'access arguments' => array('access content'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('germ_summary_form', 2, 3, 4),
    'type' => MENU_CALLBACK,
  );

  return $items;
}


/**
 * Function callback: Construct matrix and table.
 * NOTE: Show maternal parent then paternal parent when show these information.
 */
function germ_summary_form($form, &$form_state) {
  // Determine the genus from the path. If it's not included then fall back on a default.
  $genus = 'Lens';
  if (empty($form_state['build_info']['args'][0])) {
    $genus = variable_get('germ_summary_default_genus', germ_summary_get_default_genus());
  }
  else {
    $genus = $form_state['build_info']['args'][0];
  }

  $args = array(':genus' => $genus);

  // Determine parent species if they are in the path.
  if (isset($form_state['build_info']['args'][2]) AND !empty($form_state['build_info']['args'][2])) {
    $mom = $form_state['build_info']['args'][1];
    $dad = $form_state['build_info']['args'][2];
    $display = 'list';
  }
  else {
    $display = 'matrix';
  }

  // Set the title to reflect the current genus.
  drupal_set_title($genus . ' Germplasm Summary');

  //-------------------------
  // Summary Matrix.

  // Provide a quick paragraph for context.
  if ($display == 'matrix') {
    $form['description'] = array(
      '#type' => 'item',
      '#markup' => 'The following table summarizes the number of germplasm with parents of
        the specified species. Specifically, the maternal parent species is listed as
        the column header and the paternal parent species is the row header. Thus intraspecific
        crosses are shown along the center diagonal with interspecific crosses making up the
        rest of the table.'
    );
  }
  else {
    $form['description'] = array(
      '#type' => 'item',
      '#markup' => '',
    );
  }

  // Query number of children in each species crosses.
  $sql = "SELECT
            count(*) AS num_children,
            mom_org.species AS mom,
            dad_org.species AS dad
          FROM
            {stock} child

            LEFT JOIN {stock_relationship} srm ON srm.object_id = child.stock_id
            LEFT JOIN {stock} mom ON srm.subject_id = mom.stock_id
            LEFT JOIN {organism} mom_org ON mom_org.organism_id = mom.organism_id

            LEFT JOIN {stock_relationship} srd ON srd.object_id = child.stock_id
            LEFT JOIN {stock} dad ON srd.subject_id = dad.stock_id
            LEFT JOIN {organism} dad_org ON dad_org.organism_id = dad.organism_id
          WHERE
            srm.type_id IN
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_maternal_parent_of')
            AND srd.type_id IN
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_paternal_parent_of')
            AND mom_org.genus = :genus
            AND dad_org.genus = :genus
            AND child.type_id =
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'Recombinant Inbred Line')
          GROUP BY mom_org.species, dad_org.species
          ORDER BY mom_org.species ASC, dad_org.species ASC";

  $result = chado_query($sql, $args);

  // Array to hold number of children given a mom and dad.
  $arr_child_count = array();
  foreach($result as $p) {
    // Test to see matrix plots the right children to crosses.
    // dpm('Mom:' . $p->mom .' Dad:' . $p->dad . ' Count:' . $p->num_children);

    // Store the number of childre in a matrix where parents are the keys.
    $arr_child_count[$p->dad][$p->mom] = $p->num_children;
  }

  // Get all species and use this to generate headers containing maternal and paternal species.
  $sql = "SELECT organism_id, species || ' abbr: ' || abbreviation
          FROM {organism} WHERE genus = :genus ORDER BY species ASC";

  // Store the species name and use this to search for no of children
  // in the array generated by the query above.
  $arr_species_mom = $arr_species_dad = chado_query($sql, $args)
    ->fetchAllKeyed();

  // In generating the table rows, each cell (siblings count) contains
  // the maternal and paternal index in relation to index number of the
  // table header (th) in DOM. This information is stored in ID attribute
  // of the td in the following fromat: p_mom_dad eg. p_1_2 corresponds
  // to the the 1st th in maternal headers and 2nd th in paternal headers.
  // All these values will be used by JavaScript.

  // Arrays to hold table headers and rows.
  $arr_tbl_headers = array();
  // Push a blank cell to account for the corner cell in the summary.
  $arr_tbl_headers[0] = '&nbsp;';

  $arr_tbl_rows = array();

  // Move interspecific, introgression, spp., sp. to the end if present.
  foreach (array('interspecific','introgression','sp\.', 'spp\.') as $keyword) {
    // check to see if there is a key including the keyword.
    $found_key = preg_grep('/(\W+|^)'.$keyword.'\W+/', $arr_species_dad);
    if ($found_key) {
      foreach ($found_key as $k => $v) {
        // First dad,
        unset($arr_species_dad[$k]);
        $arr_species_dad[$k] = $v;
        // then Mom.
        unset($arr_species_mom[$k]);
        $arr_species_mom[$k] = $v;
      }
    }
  }

  $i = 1;
  foreach($arr_species_dad as $dad_id => $dad_name) {
    list($dad_species, $dad_abbr) = explode(' abbr: ', $dad_name);

    // Sanitize the species for use as a class name.
    $class = preg_replace('/[^-\w]+/','',str_replace(' ','-',strtolower(strip_tags($dad_species))));

    // Push mom species to header array (barrow dads name).
    array_push($arr_tbl_headers, array('data' => $dad_abbr, 'id' => 'maternal-' . $i, 'class' => array($class)));

    // Create individual table data cells containing the child count and form a
    // single row in the table. The first cell is the dad header.
    $tmp_rows = array(array('header' => true, 'data' => $dad_abbr, 'id' => 'paternal-' . $i, 'class' => array($class)));

    // See if dad matched with different moms match a count in the child count array above.
    $j = 1;
    foreach($arr_species_mom as $mom_id => $mom_name) {
      list($mom_species, $mom_abbr) = explode(' abbr: ', $mom_name);
      $names = '';

      // Check if given a mom and data, child count has a value.
      if (isset($arr_child_count[$dad_species][$mom_species])) {
        // Yes, this pair has produced cute healthy children...
        // Create a link to child summary table page.
        $child_count = l($arr_child_count[$dad_species][$mom_species],
                         'germplasm/list/' . $genus . '/' . $mom_id . '/' . $dad_id);

        // Show them the first 3 names.
        $limit = 3;
        $names_sql = "
          SELECT
            child.name
          FROM
            {stock} child

            LEFT JOIN {stock_relationship} srm ON srm.object_id = child.stock_id
            LEFT JOIN {stock} mom ON srm.subject_id = mom.stock_id
            LEFT JOIN {organism} mom_org ON mom_org.organism_id = mom.organism_id

            LEFT JOIN {stock_relationship} srd ON srd.object_id = child.stock_id
            LEFT JOIN {stock} dad ON srd.subject_id = dad.stock_id
            LEFT JOIN {organism} dad_org ON dad_org.organism_id = dad.organism_id
          WHERE
            srm.type_id IN
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_maternal_parent_of')
            AND srd.type_id IN
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_paternal_parent_of')
            AND mom_org.genus = :genus
            AND mom_org.species = :mom
            AND dad_org.genus = :genus
            AND dad_org.species = :dad
            AND child.type_id =
              (SELECT cvterm_id FROM {cvterm} WHERE name = 'Recombinant Inbred Line')
          LIMIT $limit";

        $names_args = $args;
        $names_args[':mom'] = $mom_species;
        $names_args[':dad'] = $dad_species;
        $names = chado_query($names_sql, $names_args)->fetchCol();

        if ($arr_child_count[$dad_species][$mom_species] > $limit) {
          $names[] = '...';
        }

      }
      else {
        $child_count = '<span style="color:#E6E6E6">0</span>'; // :(
      }

      // Now frame this family in a table cell.
      // Add parents to tooltip.
      $parents = '[' . $mom_abbr . ' + ' . $dad_abbr . ']';

      if ($names) {
        array_push($tmp_rows, array('data' => $child_count, 'id' => 'p-' . $j . '-' . $i, 'title' => $parents . "\n" . implode("\n",$names)));
      }
      else {
        array_push($tmp_rows, array('data' => $child_count, 'id' => 'p-' . $j . '-' . $i, 'title' => $parents));
      }

      // Next mom same dad.
      $j++;
    }

    // Create the row.
    array_push($arr_tbl_rows, $tmp_rows);

    // Next dad.
    $i++;
  }

  // Create the matrix table.
  $matrix = germ_summary_construct_table($arr_tbl_headers, $arr_tbl_rows, 'tbl-summary-matrix');

  $form['summary_matrix'] = array(
    '#markup' => $matrix,
  );

  //-------------------------
  // Germplasm List
  // for specific combo.

  // When mom and dad are requested to generate child summary table.
  if (!empty($mom) AND !empty($dad)) {
    // Validate mom and dad.
    if (array_key_exists($mom, $arr_species_mom) AND array_key_exists($dad, $arr_species_dad)) {
      list($mom, $mom_abbr) = explode(' abbr: ', $arr_species_mom[$mom]);
      list($dad, $dad_abbr) = explode(' abbr: ', $arr_species_dad[$dad]);

      // Get cvterm id of F1 - F8 Generation and RIL Complete properties.
      $sql_G = "SELECT t2.name, t2.cvterm_id
                FROM {cv} AS t1 INNER JOIN {cvterm} AS t2 USING(cv_id)
                WHERE
                  t2.name IN ('F1', 'F2', 'F3', 'F4', 'F5', 'F6', 'F7', 'F8', 'RIL_complete')
                  AND t1.name = 'stock_properties'";

      $prop = chado_query($sql_G)
        ->fetchAllKeyed();

      // Query stocks given a mom and a dad.
      $sql = "SELECT
                child.stock_id,
                child.name,
                child.uniquename AS accession,
                'node/' || child_link.nid AS child_url,

                mom.name || ' (' || mom.uniquename || ')' AS maternal_parent,
                mom_org.abbreviation AS mom_abbr,
                'node/' || mom_link.nid AS maternal_parent_url,

                dad.name || ' (' || dad.uniquename || ')' AS paternal_parent,
                dad_org.abbreviation AS dad_abbr,
                'node/' || dad_link.nid AS paternal_parent_url,

                STRING_AGG(
                   CASE
                     WHEN prop.type_id = :F1 THEN CONCAT('F1=>', TRIM(prop.value))
                     WHEN prop.type_id = :F2 THEN CONCAT('F2=>', TRIM(prop.value))
                     WHEN prop.type_id = :F3 THEN CONCAT('F3=>', TRIM(prop.value))
                     WHEN prop.type_id = :F4 THEN CONCAT('F4=>', TRIM(prop.value))
                     WHEN prop.type_id = :F5 THEN CONCAT('F5=>', TRIM(prop.value))
                     WHEN prop.type_id = :F6 THEN CONCAT('F6=>', TRIM(prop.value))
                     WHEN prop.type_id = :F7 THEN CONCAT('F7=>', TRIM(prop.value))
                     WHEN prop.type_id = :F8 THEN CONCAT('F8=>', TRIM(prop.value))
                     ELSE ''
                   END,
                ' # ') AS property_generation,

                STRING_AGG(CASE WHEN prop.type_id = :RIL_complete THEN TRIM(prop.value) END, '') AS property_complete

              FROM
                {stock} child
                LEFT JOIN chado_stock child_link ON child_link.stock_id = child.stock_id

                LEFT JOIN {stock_relationship} srm ON srm.object_id = child.stock_id
                LEFT JOIN {stock} mom ON srm.subject_id = mom.stock_id
                LEFT JOIN chado_stock mom_link ON mom_link.stock_id = mom.stock_id
                LEFT JOIN {organism} mom_org ON mom_org.organism_id = mom.organism_id

                LEFT JOIN {stock_relationship} srd ON srd.object_id = child.stock_id
                LEFT JOIN {stock} dad ON srd.subject_id = dad.stock_id
                LEFT JOIN chado_stock dad_link ON dad_link.stock_id = dad.stock_id
                LEFT JOIN {organism} dad_org ON dad_org.organism_id = dad.organism_id

                LEFT JOIN {stockprop} AS prop ON child.stock_id = prop.stock_id

              WHERE
                srm.type_id IN
                  (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_maternal_parent_of')
                AND srd.type_id IN
                  (SELECT cvterm_id FROM {cvterm} WHERE name = 'is_paternal_parent_of')
                AND mom_org.species = :mom
                AND dad_org.species = :dad
                AND child.type_id =
                  (SELECT cvterm_id FROM {cvterm} WHERE name = 'Recombinant Inbred Line')

              GROUP BY child.stock_id, child.name, child.uniquename, child_link.nid,
                       mom.name, mom.uniquename, mom_org.abbreviation, mom_link.nid,
                       dad.name, dad.uniquename, dad_org.abbreviation, dad_link.nid

              ORDER BY child.name ASC";

      $args = array(':mom' => $mom,
                    ':dad' => $dad,
                    ':F1'  => $prop['F1'],
                    ':F2'  => $prop['F2'],
                    ':F3'  => $prop['F3'],
                    ':F4'  => $prop['F4'],
                    ':F5'  => $prop['F5'],
                    ':F6'  => $prop['F6'],
                    ':F7'  => $prop['F7'],
                    ':F8'  => $prop['F8'],
                    ':RIL_complete' => $prop['RIL_complete']);

      $child = chado_query($sql, $args);

      if ($child->rowCount() > 0) {
        // Path to module
        // 4 dir up - germplasm/list/Lens/% mom/% dad
        $path = '../../../../' . drupal_get_path('module', 'germ_summary') . '/theme/img/';

        // Target links in the table to new page.
        $attributes = array('attributes' => array('target' => '_blank'));

        // Arrays to hold table headers and rows.
        $arr_tbl_headers = array(
          t('Name'),
          t('Accession'),
          t('Maternal Parent'),
          t('Paternal Parent'),
        );

        // Push Generations (F1 - F8) + Completed Property.
        // F1 - F8 image column headers.
        for($i = 1; $i < 9; $i++) {
          $arr_tbl_headers[] = '<img src="' . $path . 'header-f' . $i . '.jpg' . '" alt="' . 'F' . $i . '" title="' . 'F' . $i . '" />';
        }

        // HEADER: RIL_complete property.
        $arr_tbl_headers[] = '<img src="' . $path . 'header-finished.jpg' . '" alt="RIL Complete" title="RIL complete" />';

        // Array to hold table rows.
        $arr_tbl_rows = array();

        foreach($child as $i => $c) {
          // Create a link to child, mom and dad info page.
          // Child link.
          $child_link = l($c->name, $c->child_url, $attributes);
          // Maternal link.
          $mommy_link = l($c->maternal_parent, $c->maternal_parent_url, $attributes);
          // Paternal link.
          $daddy_link = l($c->paternal_parent, $c->paternal_parent_url, $attributes);

          // Push other stock information cell value.
          $arr_row_cell_value =  array($child_link, $c->accession, $mommy_link, $daddy_link);

          // Push stock generation and RIL complete cell values.
          // Test each to see if it has a value.
          // When set but with an empty value, add a check icon, otherwise, add text/numeric value.

          // Get stock property generation => property value list.
          $arr_F_values = array();
          $prop_gen = explode(' # ', $c->property_generation);

          // Read each F generation property type and value pair.
          foreach($prop_gen as $prop) {
            if (trim($prop) != '') {
              // Extract the F generation property type and value only when value
              // is not empty.
              list($F_gen, $F_gen_value) = explode('=>', $prop);

              // For each F generation propertytype, create an array where the key is the property type and
              // value is the corresponding value.
              $arr_F_values[$F_gen] = $F_gen_value;
            }
          }

          // Create the cell value for F1 to F8 property type.
          for($i = 1; $i < 9; $i++) {
            $F = 'F' . $i;

            $F_val = isset($arr_F_values[$F]) ? $arr_F_values[$F] : null;
            $arr_row_cell_value[] = germ_summary_generate_cell_value($F_val, $F);
          }

          // Create the cell value for RIL complete.
          $arr_row_cell_value[] = germ_summary_generate_cell_value($c->property_complete, 'RIL');

          array_push($arr_tbl_rows, $arr_row_cell_value);
        }

        // Pager:
        // Number of rows per page.
        $pager_rows_per_page = 25;
        // Current page number in pager.
        $pager_current_page = pager_default_initialize(count($arr_tbl_rows), $pager_rows_per_page);
        // Show the rows for a page number.
        $pager_row_set = array_chunk($arr_tbl_rows, $pager_rows_per_page, TRUE);

        // Create child summary table.
        $sum_table = germ_summary_construct_table($arr_tbl_headers, $pager_row_set[$pager_current_page], 'tbl-summary-table');

        // Add another table header to contain header for generations and finished property.
        // 3 columns 1 row - first col empty (Stock info) 2nd col Generations 3rd col empty (Finished property).
        $sum_table = str_replace('<thead>',
          '<thead>
            <tr class="headings">
              <th colspan="4">&nbsp;</th>
              <th colspan="8">Generations</th>
              <th>&nbsp</th>
            </tr>
          ', $sum_table);

        $form['back_link'] = array(
          '#type' => 'markup',
          '#markup' => l('Back to Summary Matrix', 'germplasm/summary/' . $genus),
        );

        $form['summary_table'] = array(
          '#markup' => $sum_table . theme('pager', array('quantity', count($arr_tbl_rows))),
        );

        // Summary table title information.
        // Sibling count.
        $form['siblings_count'] = array(
          '#type' => 'hidden',
          '#value' => count($arr_tbl_rows),
        );

        // Mommy's name.
        $form['siblings_mom'] = array(
          '#type' => 'hidden',
          '#value' => $mom_abbr,
        );

        // Dad's name.
        $form['siblings_dad'] = array(
          '#type' => 'hidden',
          '#value' => $dad_abbr,
        );
      }
      else {
        // No children found
        drupal_set_message('Species returned 0 result', 'error');
      }
    }
    else {
      // Parents dont exist.
      drupal_set_message('Maternal and/or Paternal parent not found.', 'error');
    }
  }

  $path = drupal_get_path('module', 'germ_summary') . '/theme/';
  $form['#attached']['css'] = array($path . 'css/germ_summary.style.css');
  $form['#attached']['js']  = array($path . 'js/germ_summary.script.js');

  return $form;
}


/**
 * Implements hook_theme().
 */
function germ_summary_theme($existing, $type, $theme, $path) {
  $items['germ_summary_form'] = array(
    'render element' => 'form',
    'template' => 'germ_summary_matrix',
    'path' => $path . '/theme',
  );

  return $items;
}

/**
 * Helper Function: Determine the default genus.
 *
 * We're going to assume that the genus with the most species is the one they want...
 * If two genus' have the same number of species then the default is chosen aphabetically.
 *
 * @return
 *   The genus to use as the default.
 */
function germ_summary_get_default_genus() {

  // Grab the genus with the most species.
  $genus = chado_query('
    SELECT t.genus
    FROM (
        SELECT genus, count(*) as num_species
        FROM {organism}
        GROUP BY genus
      ) t
    ORDER BY t.num_species DESC, t.genus ASC
    LIMIT 1
  ')->fetchField();

  // If that worked then save it for faster use later.
  if ($genus) {
    variable_set('germ_summary_default_genus', $genus);
  }

  return $genus;
}

/**
 * Function helper: Construct a Drupal theme table.
 *
 * @param $headers
 *   An array containing the headers of the table.
 * @param $rows
 *   An array containing the rows of the table.
 * @param $tbl_id
 *   A string containing the id attribute of the table.
 *
 * @return
 *   Drupal theme table.
 */
function germ_summary_construct_table($headers, $rows, $tbl_id) {
  // Array to Hold Drupal Table properties.
  $arr_tbl_args = array();

  $arr_tbl_args['header']     = $headers;
  $arr_tbl_args['rows']       = $rows;
  $arr_tbl_args['sticky']     = ($tbl_id == 'tbl-summary-table') ? FALSE : TRUE;
  $arr_tbl_args['attributes'] = array('id' => $tbl_id);

  return theme('table', $arr_tbl_args);
}

/**
 * Function helper: Generete the correct value to a table cell given a Stock Property Value.
 *
 * @param $prop_value
 *   The value of a given Stock Property.
 * @param $prop_type
 *   The type of stock property of a given property value.
 *   RIL - for RIL complete
 *   F%  - for F1 - F8 generation
 *
 * @return
 *   Exists but empty: Check icon (image).
 *   Exists but has value: Display the value (text/numeric).
 *   Does not exist: Blank space.
 */
function germ_summary_generate_cell_value($prop_value, $prop_type) {
  if (isset($prop_value)) {
    if ($prop_value == '') {
      // Check mark image icon.
      $attr_image = '../../../../' . drupal_get_path('module', 'germ_summary') . '/theme/img/message-16-ok.png';
      // Alternate text (alt/title) attribute of the icon image.
      $attr_title = ($prop_type == 'RIL') ? 'RIL Complete' : 'Generation ' . $prop_type;

      $cell_val = '<img src="' . $attr_image . ' " alt="' . $attr_title . '" title="' . $attr_title . '" />';
    }
    else {
      $cell_val = $prop_value;
    }
  }
  else {
    $cell_val = '&nbsp;';
  }

  return $cell_val;
}
